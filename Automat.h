/* 
* Automat.h
*
* Created: 14.05.2023 19:51:05
* Author: Thomas Heß
*/


#ifndef __CLASSAUTOMAT_H__
#define __CLASSAUTOMAT_H__

#include <cstdint>
#include <stddef.h>  // für NULL
#include <stdint.h>
#include "Zustand_Oberklasse.h"
#include "Ereignisse_Transition_Oberklasse.h" // Definition of all possible Events
#include "Automat_Transitionen.h"
#include "Automat_Zustaende.h"
#include "StateMachine.h"
#include "Hardware_Methoden.h" // Damit Automat auf die Hardware (GPIO, ADC, UART, ...) zugreifen kann


/** Define the number of ticks in a second, generated by a timer interrupt */
#define TICKS_PER_SECOND  10 // Timer7 100ms

/** Macro to calculate the number of ticks in a second */
#define Seconds(x)        (x*TICKS_PER_SECOND)

/** Timeout in Seconds */
#define TIMEOUT           15


enum {
	/** Size of Event Queue */
	EventQueueSize = 4
};



class Automat
{
//variables
protected:
private:


    /* Tabelle Vollschritt links
    A   A/  B   B/
    PC3 PC2 PC1 PC0
    1   0   1   0
    1   0   0   1
    0   1   0   1
    0   1   1   0
*/
uint8_t vollschritt[4]={0b0110,0b0101,0b1001,0b1010};
int16_t position = 0;
bool richtung = true; // Rechtslauf: true, Linkslauf: false
uint16_t schrittdauer = 100; // Schrittdauer in ms





	// Zustände, Objekte aus den jeweiligen Zustandsklassen in ClassApplicationStates.h

	
    StateInitialisierung initialisierung;
	StateStopp           stopp; 
     

	State* const                initState = &initialisierung; // Erster Zustand nach Pseudo-Start-Zustand

	// Transitionen, Objekte aus den jeweiligen Zustandsklassen in Automat_Transitionen.h

	Trans_Initialisierung_Stopp initialisierung2stopp;
    

	// Finite State Machine, Objekt aus StateMachine.h
	StateMachine eineFSM;

	// Zustandsfolgetabelle für diesen Automaten

 
	State2State fsmApp[1] = {
		// currentState State*   transition	ClassTransition*					   nextState State*	altState State*

		{&initialisierung  ,    &initialisierung2stopp,                               &stopp,         NULL        },
        

	};

	volatile Events evQueue[EventQueueSize]; // Feld aus Event-enum, in der die einzelnen aufgetretenen Ereignisse abgelegt werden

//functions
public:
	Automat();
	~Automat();
	 
	/* Initializes the Finite State Machine  */
	void init(); // ruft init() aus StateMachine auf!
	
	/* Send an Event to the Application, note: The Event must be processed by process() */
	void sendEvent(Events); // ruft sendEvent() aus StateMachine auf!
	
	 /* Process Event if one is available and perform change of state, return True if there was an Event available */
	 bool process_StateChange(); // ruft StateChange() aus StateMachine auf!
	 

     uint16_t fsm_get_timeInState(); // ruft get_timeInState() aus der StateMachine auf!

     void fsm_set_timeInState(uint16_t); // ruft set_timeInState() aus der StateMachine auf!
     

     
     


}; // ClassAutomat

#endif //__CLASSAUTOMAT_H__
